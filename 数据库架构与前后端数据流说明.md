# 数据库架构与前后端数据流说明

## 概述

本项目采用轻量级"文件数据库"方案，使用 `db.json` 作为持久化存储，通过服务端 Actions 提供数据操作接口，实现服务端渲染(SSR)与客户端交互的完整数据流。

## 架构分层

```
┌─────────────────────────────────────────────────────────────┐
│                    前端层 (Frontend)                          │
├─────────────────────────────────────────────────────────────┤
│  app/(pages)/page.tsx          │  app/_components/paginate/  │
│  (服务端组件 - SSR渲染)          │  (客户端组件 - 交互)        │
└─────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────┐
│                   服务端 Actions 层                          │
├─────────────────────────────────────────────────────────────┤
│  app/actions/post.ts                                        │
│  (Server Actions - 数据操作接口)                             │
└─────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────┐
│                    数据层 (Database)                         │
├─────────────────────────────────────────────────────────────┤
│  database/generator.ts        │  database/types.ts          │
│  (文件读写 + 初始化)           │  (类型定义)                  │
│  database/db.json             │                             │
│  (JSON文件存储)                │                             │
└─────────────────────────────────────────────────────────────┘
```

## 核心文件详解

### 1. 数据层 (`src/database/`)

#### `generator.ts` - 文件数据库核心

```typescript
'use server'; // 强制服务端运行，避免客户端文件系统调用

// 核心职责：
// 1. 生成初始演示数据（22篇文章）
// 2. 确保 db.json 存在，不存在则创建
// 3. 提供读写接口：readDbFile() 和 resetDbFile()
```

**关键函数：**

- `checkDbFile()`: 检测并创建 `db.json`，写入初始数据
- `readDbFile()`: 读取所有文章数据
- `resetDbFile(data)`: 重写整个数据库文件

**初始数据生成：**

```typescript
const posts: IPost[] = [...Array.from({ length: 22 }).keys()].map(() => ({
    id: v4(), // UUID
    thumb: `/uploads/thumb/post-${getRandomInt(1, 8)}.png`, // 随机封面
    title: faker.lorem.paragraph({ min: 1, max: 3 }), // 1-3段标题
    body: faker.lorem.paragraphs(getRandomInt(3, 6), '\n'), // 3-6段内容
    summary: Math.random() < 0.5 ? faker.lorem.text() : undefined, // 50%概率摘要
}));
```

#### `types.ts` - 类型定义

```typescript
// 文章数据结构
export interface IPost {
    id: string; // UUID
    title: string; // 标题
    body: string; // 内容
    thumb: string; // 封面图路径
    summary?: string; // 可选摘要
}

// 分页相关类型
export interface PaginateOptions {
    page?: number;
    limit?: number;
}
export interface PaginateMeta {
    itemCount: number;
    totalItems?: number;
    perPage: number;
    totalPages?: number;
    currentPage: number;
}
export interface PaginateReturn<E> {
    meta: PaginateMeta;
    items: E[];
}
```

#### `db.json` - 数据存储

- JSON 格式存储所有文章数据
- 首次运行自动生成，包含 22 篇演示文章
- 所有增删改操作都重写此文件

### 2. 服务端 Actions 层 (`src/app/actions/post.ts`)

```typescript
'use server'; // Server Actions，只能在服务端调用

// 核心功能：
// 1. 分页查询文章列表
// 2. 根据ID查询单篇文章
// 3. 新增文章
// 4. 更新文章
// 5. 删除文章
```

**关键函数：**

#### 分页查询

```typescript
export const queryPostPaginate = async (
    options?: PaginateOptions,
): Promise<PaginateReturn<IPost>> => {
    const posts = (await readDbFile()).reverse(); // 倒序：新文章在前
    return paginate(posts, { page: 1, limit: 8, ...options });
};
```

#### 单篇文章查询

```typescript
export const queryPostItemById = async (id: string): Promise<IPost | null> => {
    const posts = await readDbFile();
    const item = posts.find((post) => post.id === id);
    if (isNil(item)) throw new Error('post not exists!');
    return item;
};
```

#### 新增文章

```typescript
export const createPostItem = async (data: Omit<IPost, 'id'>): Promise<IPost> => {
    const posts = await readDbFile();
    const item: IPost = {
        ...data,
        id: v4(),
        thumb: `/uploads/thumb/post-${getRandomInt(1, 8)}.png`,
    };
    posts.push(item);
    await resetDbFile(posts); // 持久化到文件
    return item;
};
```

#### 更新文章

```typescript
export const updatePostItem = async (
    id: string,
    data: Partial<Omit<IPost, 'id'>>,
): Promise<IPost | null> => {
    let posts = await readDbFile();
    const item = await queryPostItemById(id);
    if (isNil(item)) return null;

    const result = { ...item, ...data } as IPost;
    posts = posts.map((post) => (post.id === id ? result : post));
    await resetDbFile(posts);
    return result;
};
```

#### 删除文章

```typescript
export const deletePostItem = async (id: string): Promise<IPost | null> => {
    let posts = await readDbFile();
    const item = await queryPostItemById(id);
    if (isNil(item)) return null;

    posts = posts.filter((post) => post.id !== id);
    await resetDbFile(posts);
    return item;
};
```

### 3. 前端层

#### 服务端页面 (`src/app/(pages)/page.tsx`)

```typescript
// 服务端组件 - 在服务器端执行，直接调用 Server Actions
const HomePage: FC<{ searchParams: IPaginateQueryProps }> = async ({ searchParams }) => {
    const { page: currentPage, limit = 8 } = searchParams;
    const page = isNil(currentPage) || Number(currentPage) < 1 ? 1 : Number(currentPage);

    // 服务端直接调用，获取分页数据
    const { items, meta } = await queryPostPaginate({ page: Number(page), limit });

    // 越界保护
    if (meta.totalPages && meta.totalPages > 0 && page > meta.totalPages) {
        return redirect('/');
    }

    return (
        <div className="page-item">
            {/* 渲染文章列表 */}
            {items.map((item) => (
                <div key={item.id}>
                    <Link href={`/posts/${item.id}`}>
                        <Image src={item.thumb} alt={item.title} />
                    </Link>
                    <h2>{item.title}</h2>
                    <div>{item.summary || item.body.substring(0, 99)}</div>
                </div>
            ))}

            {/* 分页组件 */}
            {meta.totalPages > 1 && <PostListPaginate limit={5} page={page} />}
        </div>
    );
};
```

#### 客户端分页组件 (`src/app/_components/paginate/simple.tsx`)

```typescript
'use client'; // 客户端组件

export const Pagination: FC<{ totalPages: number; currentPage: number }> = ({
    totalPages, currentPage,
}) => {
    const searchParams = useSearchParams();
    const router = useRouter();
    const pathname = usePathname();

    // 生成分页链接
    const getPageUrl = useCallback((value: number) => {
        const params = new URLSearchParams(searchParams);
        value <= 1 ? params.delete('page') : params.set('page', value.toString());
        return pathname + (params.toString() ? `?${params.toString()}` : '');
    }, [searchParams]);

    // 首页清理 page 参数
    useEffect(() => {
        const params = new URLSearchParams(searchParams);
        if (currentPage <= 1) params.delete('page');
        router.replace(pathname + (params.toString() ? `?${params.toString()}` : ''));
    }, [currentPage]);

    return totalPages > 1 ? (
        <CNPagination>
            <PaginationPrevious href={getPageUrl(currentPage - 1)} disabled={currentPage <= 1} />
            <PaginationNext href={getPageUrl(currentPage + 1)} disabled={currentPage >= totalPages} />
        </CNPagination>
    ) : null;
};
```

## 数据流详解

### 读取数据流（分页浏览）

```
1. 用户访问 /?page=2
   ↓
2. 服务端页面组件执行
   ↓
3. 调用 queryPostPaginate({ page: 2, limit: 8 })
   ↓
4. Server Action 调用 readDbFile() 读取 db.json
   ↓
5. 数据倒序 + 分页计算，返回 { items, meta }
   ↓
6. 服务端渲染 HTML，返回给浏览器
   ↓
7. 客户端分页组件监听 URL 变化，提供交互
```

### 写入数据流（新增/修改/删除）

```
1. 前端触发 Server Action（如 createPostItem）
   ↓
2. Server Action 调用 readDbFile() 获取现有数据
   ↓
3. 执行增删改操作
   ↓
4. 调用 resetDbFile() 重写 db.json
   ↓
5. 页面刷新或重新请求，读取更新后的数据
   ↓
6. 新数据按倒序显示在列表前部
```

### 分页交互流

```
1. 用户点击分页按钮
   ↓
2. 客户端组件更新 URL 查询参数 (?page=3)
   ↓
3. Next.js 路由变化触发页面重新渲染
   ↓
4. 服务端页面组件重新执行，获取新参数
   ↓
5. 重新调用 queryPostPaginate 获取第3页数据
   ↓
6. 服务端渲染新页面，返回给浏览器
```

## 关键设计原则

### 1. 运行环境隔离

- **服务端**：`'use server'` 标记的文件只能在服务端运行
- **客户端**：`'use client'` 标记的组件在浏览器运行
- **文件系统**：只能在服务端访问，确保安全性

### 2. 数据一致性

- 所有数据操作都通过 `readDbFile()` 和 `resetDbFile()` 进行
- 每次修改都重写整个文件，保证数据一致性
- 服务端 Actions 提供原子性操作

### 3. SSR + 客户端交互

- 首屏通过服务端渲染，提升加载速度
- 分页等交互通过客户端组件处理
- URL 变化驱动服务端重新渲染

### 4. 类型安全

- TypeScript 类型定义贯穿整个数据流
- 接口定义清晰，便于维护和扩展

## 注意事项与优化建议

### 当前存在的问题

1. **分页显示 Bug**：`page.tsx` 中 `meta.totalPages !> 1` 应为 `meta.totalPages > 1`
2. **调试代码**：分页组件中的 `console.log` 应移除或受环境控制

### 性能优化建议

1. **数据量增大时**：考虑引入真正的数据库（如 SQLite、PostgreSQL）
2. **缓存策略**：可以添加内存缓存减少文件读取
3. **分页优化**：大数据量时考虑游标分页而非偏移分页

### 扩展性考虑

1. **数据验证**：可以添加 Zod 等库进行数据验证
2. **错误处理**：完善错误边界和异常处理
3. **日志记录**：添加操作日志便于调试和监控

## 总结

这个架构的核心优势：

- **简单直接**：文件数据库易于理解和调试
- **类型安全**：完整的 TypeScript 支持
- **SSR 友好**：服务端渲染提升首屏性能
- **开发友好**：自动初始化数据，无需手动准备

适合中小型项目快速开发，当数据量和并发需求增长时，可以平滑迁移到真正的数据库系统。
